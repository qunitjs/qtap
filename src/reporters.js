import util from 'node:util';

import yaml from 'yaml';

import { shortenTestFileLabels } from './util.js';

function dynamic (_eventbus) {
// const icons = { waiting: '⢎', progress: '⠧', success: '✔', failure: '✘' };
// "interval": 80,
// "frames": [
//     "⠋",
//     "⠙",
//     "⠹",
//     "⠸",
//     "⠼",
//     "⠴",
//     "⠦",
//     "⠧",
//     "⠇",
//     "⠏"
// ]
// "frames": [
//     "⢎ ",
//     "⠎⠁",
//     "⠊⠑",
//     "⠈⠱",
//     " ⡱",
//     "⢀⡰",
//     "⢄⡠",
//     "⢆⡀"
// ]
//   let screen = '';
//   function render () {
//     let str = '';
//     if (screen) {
//       const oldHeight = screen.split('\n').length;
//       for (let i = 1; i < oldHeight; i++) {
//         process.stdout.write('\x1b[A\x1b[K');
//       }
//     }
//     process.stdout.write(str);
//     screen = str;
//   }
}

function plain (eventbus) {
  const WAIT_MSG_GRACE = 3000;
  const TEST_MSG_GRACE = 1000;

  let perfOrigin;

  /**
   * @typedef {Object} Client
   * @property {string} clientId
   * @property {string} testFile
   * @property {string} browser
   * @property {string} linePrefix
   * @property {string[]} clientconsole Temporary buffer
   * @property {number} completed Number of tests completed so far
   * @property {any} waitMsgTimer
   * @property {any} testMsgTimer
   */
  /** @type {Map<string,Client>} */
  const clients = new Map();

  // De-duplicated set of test files
  const testFiles = new Set();

  let browserCount;

  function printAnyClientConsoleLines (client) {
    // Print consecutive lines from the same client together instead of repeating the client prefix,
    // to improve readability and reduce line length.
    // These likely arrived in a batch as part of a single message (e.g. stack trace)
    if (client.clientconsole.length) {
      console.log(util.styleText('grey', client.linePrefix) + 'Console:\n' + util.styleText('yellow', client.clientconsole.join('\n')));
      client.clientconsole.length = 0;
    }
  }

  function formatFailure (itemMarker = '', result, includeDiag, client, itemIndent) {
    let ret = itemMarker + result.fullname;
    if (includeDiag) {
      /** @type {Object|undefined} */
      const diag = result.diag;
      if (diag) {
        ret += '\n' + yaml.stringify(diag, { lineWidth: 0 })
          .replace(/^/mg, itemIndent)
          .replace(/^(\s*)([^:]+:)( )/mg, (_, pre, key, post) => pre + util.styleText('grey', key) + post);
      }
      if (client.clientconsole.length) {
        ret += `\n${itemIndent}Console:\n` + util.styleText('yellow', itemIndent + client.clientconsole.join('\n' + itemIndent));
        client.clientconsole.length = 0;
      }

      // TODO: Add support for diag.diff provided by test framework/reporter (e.g. QUnit 3.1).
      // We'll need to pick out and unset diag.diff before yaml.stringify(diag)
      // so that color codes work, because yaml.stringify would escape them,
      // making the diff unreadable.
      //
      // TODO: Add support for fallback diff generated by QTap between actual/expected.
    }
    return ret;
  }

  eventbus.on('clients', (event) => {
    for (const clientId in event.clients) {
      testFiles.add(event.clients[clientId].testFile);
    }
    browserCount = (Object.keys(event.clients).length / testFiles.size);

    const shortened = shortenTestFileLabels(testFiles);
    const shortLabelMax = (
      (testFiles.size > 1
        ? Math.max(
          ...[...shortened.values()].map((shortLabel) => shortLabel.length)
        )
        : 0
      )
      + (browserCount > 1 && testFiles.size > 1 ? 1 : 0)
      + (browserCount > 1
        ? Math.max(
          ...[...Object.values(event.clients)].map((clientEvent) => clientEvent.displayName.length)
        )
        : 0
      )
    );
    const linePrefixPad = Math.min(38, shortLabelMax);

    for (const clientId in event.clients) {
      const clientEvent = event.clients[clientId];

      const shortLabel = ''
        + (testFiles.size > 1 ? shortened.get(clientEvent.testFile) : '')
        + (browserCount > 1 && testFiles.size > 1 ? '@' : '')
        + (browserCount > 1 ? clientEvent.displayName : '');

      /** @type {Client} */
      const client = {
        clientId: clientId,
        testFile: clientEvent.testFile,
        browser: clientEvent.displayName,
        linePrefix: shortLabel ? '[' + shortLabel.padEnd(linePrefixPad, ' ') + '] ' : '',
        clientconsole: [],
        completed: 0,
        waitMsgTimer: null,
        testMsgTimer: null,
      };
      clients.set(clientId, client);

      client.waitMsgTimer = setTimeout(() => {
        const line = util.styleText('grey', `${client.linePrefix}⠧ Waiting for browser to connect`);
        console.log(line);
      }, WAIT_MSG_GRACE);
    }
  });

  eventbus.on('clientonline', (event) => {
    const client = /** @type {Client} */ (clients.get(event.clientId));
    clearTimeout(client.waitMsgTimer);

    perfOrigin ??= performance.now();

    let line;
    if (browserCount === 1) {
      line = util.styleText('grey', `${client.linePrefix}⠧ Running tests in ${client.browser}`);
    } else {
      line = util.styleText('grey', `${client.linePrefix}⠧ Running tests...`);
    }
    console.log(line);
  });

  eventbus.on('clientconsole', (event) => {
    const client = /** @type {Client} */ (clients.get(event.clientId));

    client.clientconsole.push(event.message);
  });

  eventbus.on('assert', (event) => {
    const client = /** @type {Client} */ (clients.get(event.clientId));

    client.completed++;

    if (event.ok) {
      client.clientconsole.length = 0;
      client.testMsgTimer ??= setTimeout(() => {
        const line = util.styleText('grey', `${client.linePrefix}⠧ Ran ${client.completed} ${client.completed === 1 ? 'test' : 'tests'}...`);
        console.log(line);
        client.testMsgTimer = null;
      }, TEST_MSG_GRACE);
    } else {
      clearTimeout(client.testMsgTimer);
      client.testMsgTimer = null;
      console.log(formatFailure(
        util.styleText('grey', client.linePrefix) + util.styleText('red', '✘') + ' ',
        event,
        true,
        client,
        '  '
      ));
    }
  });

  const clientresults = {
    skips: {},
    todos: {}
  };
  eventbus.on('clientresult', (event) => {
    const client = /** @type {Client} */ (clients.get(event.clientId));

    clearTimeout(client.testMsgTimer);

    if (event.skips?.length) {
      clientresults.skips[event.clientId] = event.skips;
    }
    if (event.todos?.length) {
      clientresults.todos[event.clientId] = event.todos;
    }

    if (event.ok) {
      if (browserCount > 1) {
        const line = util.styleText('grey', `${client.linePrefix}✔ Completed ${client.completed} ${client.completed === 1 ? 'test' : 'tests'}`);
        console.log(line);
      } else {
        if (client.testMsgTimer) {
          client.testMsgTimer = null;
          const line = util.styleText('grey', `${client.linePrefix}⠧ Ran ${client.completed} ${client.completed === 1 ? 'test' : 'tests'}...`);
          console.log(line);
        }
      }
    } else {
      printAnyClientConsoleLines(client);
    }
  });

  eventbus.on('finish', (event) => {
    const durationSec = (performance.now() - perfOrigin) / 1000;
    // Format 120ms > 0.1s, 450ms > 0.5s, 951ms > 1s, 2048ms > 2s
    const durationFormatted = (
      durationSec > 1 ? Math.floor(durationSec) : durationSec.toPrecision(1)
    ) + 's';

    formatSection(
      (num) => util.styleText(['bgYellowBright'],
        util.styleText('yellowBright', '__')
        + util.styleText(['black', 'bold'], `${num} SKIPPED`)
        + util.styleText('yellowBright', '__')
      ),
      clientresults.skips,
      false
    );

    formatSection(
      (num) => util.styleText(['bgCyanBright'],
        util.styleText('cyanBright', '__')
        + util.styleText(['black', 'bold'], `${num} TODOS`)
        + util.styleText('cyanBright', '__')
      ),
      clientresults.todos
    );

    let statusLine;
    if (event.ok) {
      statusLine = util.styleText(['bgGreenBright'],
        util.styleText('greenBright', '__')
        + util.styleText(['black', 'bold'], '\u2714 DONE')
        + util.styleText('greenBright', '__')
      );
    } else {
      statusLine = util.styleText(['bgRedBright'],
        util.styleText('redBright', '__')
        + util.styleText(['whiteBright', 'bold'], `${event.failed} FAILURES`)
        + util.styleText('redBright', '__')
      );
    }
    console.log('\n' + statusLine + '\n');

    const footerLine = `Completed ${event.total} tests in ${durationFormatted}`;
    console.log(util.styleText('grey', footerLine));
  });

  eventbus.on('error', () => {
    for (const client of clients.values()) {
      clearTimeout(client.waitMsgTimer);
      clearTimeout(client.testMsgTimer);
      client.testMsgTimer = null;
      printAnyClientConsoleLines(client);
    }
  });

  /**
   * @param {Function} headingFn
   * @param {Object} resultsByClient
   * @param {boolean} includeDiag
   */
  function formatSection (headingFn, resultsByClient, includeDiag = true) {
    let count = 0;
    for (const clientId in resultsByClient) {
      count += resultsByClient[clientId].length;
    }
    if (!count) {
      return;
    }

    console.log('\n' + headingFn(count) + '\n');
    let i = 0;
    for (const clientId in resultsByClient) {
      const client = /** @type {Client} */ (clients.get(clientId));

      for (const result of resultsByClient[clientId]) {
        i++;
        const itemMarker = i + '. ';
        const itemIndent = ' '.repeat(itemMarker.length);
        console.log(formatFailure(
          util.styleText('grey', itemMarker + client.linePrefix),
          result,
          includeDiag,
          client,
          itemIndent
        ));
      }
    }
  }
}

const isTTY = false; // process.stdout.isTTY && process.env.TERM !== 'dumb';
const minimal = isTTY ? dynamic : plain;

function none (_eventbus) {}

export default { none, minimal };

// TODO: Add a 'tap' reporter, that merges and verbosely merges and forwards
// all original tap lines. Test names prepended with "Test file in Browser > ".

/*

# Minimal reporter in dynamic mode (isTTY=true)

  ===============================================================

  $ qtap test/fixtures/pass.html
  [Firefox Headless] ⠧ ok 2 Baz > this thing
  [Chrome Headless ] ⠧ ok 1 Foo bar

  ===============================================================

  $ qtap --timeout 3 test/fixtures/timeout.html
  [Firefox Headless] ✘ Test timed out after 30s
  [Chrome Headless ] ✘ Test timed out after 30s

  ===============================================================

  Running /test/connect-timeout.html
  $ bin/qtap.js -c test/fixtures/qtap.config.js -b fakeRefuse test/fixtures/pass.html
  [Firefox Headless] ⢎ Waiting for browser to connect...
  [Chrome Headless ] ⢎ Waiting for browser to connect...

  ===============================================================

  $ bin/qtap.js -c test/fixtures/qtap.config.js --connect-timeout 3 -b fakeRefuse test/fixtures/pass.html
  ✘ Browser did not start within 6s

  $ bin/qtap.js -c test/fixtures/qtap.config.js --connect-timeout 3 -b fakeLazy test/fixtures/fake_pass_4.txt
  ⠧ Waiting for browser to connect
  ⠧ Running tests in fakeLazy
  ✔ Completed 4 tests

  ===============================================================

  $ qtap -c test/fixtures/qtap.config.js -b fakeRefuseAlways test/fixtures/pass.html
  ✘ Browser did not start within 60s after 3 attempts.

*/
